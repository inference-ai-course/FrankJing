arXiv:cs/9809026v1  [cs.CL]  18 Sep 1998
Preﬁx Probabilities from Stochastic Tree Adjoining Grammars∗
Mark-Jan Nederhof
DFKI
Stuhlsatzenhausweg 3,
D-66123 Saarbr¨ucken,
Germany
nederhof@dfki.de
Anoop Sarkar
Dept. of Computer and Info. Sc.
Univ of Pennsylvania
200 South 33rd Street,
Philadelphia, PA 19104 USA
anoop@linc.cis.upenn.edu
Giorgio Satta
Dip. di Elettr. e Inf.
Univ. di Padova
via Gradenigo 6/A,
35131 Padova, Italy
satta@dei.unipd.it
Abstract
Language models for speech recognition typ-
ically use a probability model of the form
Pr(an|a1, a2, . . . , an−1).
Stochastic grammars,
on the other hand, are typically used to as-
sign structure to utterances. A language model
of the above form is constructed from such
grammars by computing the preﬁx probabil-
ity P
w∈Σ∗Pr(a1 · · · anw), where w represents
all possible terminations of the preﬁx a1 · · · an.
The main result in this paper is an algorithm
to compute such preﬁx probabilities given a
stochastic Tree Adjoining Grammar (TAG).
The algorithm achieves the required computa-
tion in O(n6) time.
The probability of sub-
derivations that do not derive any words in the
preﬁx, but contribute structurally to its deriva-
tion, are precomputed to achieve termination.
This algorithm enables existing corpus-based es-
timation techniques for stochastic TAGs to be
used for language modelling.
1
Introduction
Given some word sequence a1 · · · an−1, speech
recognition language models are used to hy-
pothesize the next word an, which could be
any word from the vocabulary Σ.
This
is typically done using a probability model
Pr(an|a1, . . . , an−1). Based on the assumption
that modelling the hidden structure of nat-
∗Part of this research was done while the ﬁrst and the
third authors were visiting the Institute for Research
in Cognitive Science, University of Pennsylvania. The
ﬁrst author was supported by the German Federal Min-
istry of Education, Science, Research and Technology
(BMBF) in the framework of the Verbmobil Project un-
der Grant 01 IV 701 V0, and by the Priority Programme
Language and Speech Technology, which is sponsored by
NWO (Dutch Organization for Scientiﬁc Research). The
second and third authors were partially supported by
NSF grant SBR8920230 and ARO grant DAAH0404-94-
G-0426. The authors wish to thank Aravind Joshi for
his support in this research.
ural language would improve performance of
such language models, some researchers tried to
use stochastic context-free grammars (CFGs) to
produce language models (Wright and Wrigley,
1989; Jelinek and Laﬀerty, 1991; Stolcke, 1995).
The probability model used for a stochas-
tic grammar was P
w∈Σ∗Pr(a1 · · · anw). How-
ever, language models that are based on tri-
gram probability models out-perform stochastic
CFGs. The common wisdom about this failure
of CFGs is that trigram models are lexicalized
models while CFGs are not.
Tree Adjoining Grammars (TAGs) are impor-
tant in this respect since they are easily lexical-
ized while capturing the constituent structure
of language.
More importantly, TAGs allow
greater linguistic expressiveness. The trees as-
sociated with words can be used to encode argu-
ment and adjunct relations in various syntactic
environments. This paper assumes some famil-
iarity with the TAG formalism. (Joshi, 1988)
and (Joshi and Schabes, 1992) are good intro-
ductions to the formalism and its linguistic rele-
vance. TAGs have been shown to have relations
with both phrase-structure grammars and de-
pendency grammars (Rambow and Joshi, 1995),
which is relevant because recent work on struc-
tured language models (Chelba et al., 1997) have
used dependency grammars to exploit their lex-
icalization. We use stochastic TAGs as such a
structured language model in contrast with ear-
lier work where TAGs have been exploited in
a class-based n-gram language model (Srinivas,
1996).
This paper derives an algorithm to compute
preﬁx probabilities P
w∈Σ∗Pr(a1 · · · anw). The
algorithm assumes as input a stochastic TAG G
and a string which is a preﬁx of some string in
L(G), the language generated by G. This algo-
rithm enables existing corpus-based estimation
techniques (Schabes, 1992) in stochastic TAGs
to be used for language modelling.

2
Notation
A stochastic Tree Adjoining Grammar (STAG)
is represented by a tuple (NT, Σ, I, A, φ) where
NT is a set of nonterminal symbols, Σ is a set
of terminal symbols, I is a set of initial trees
and A is a set of auxiliary trees. Trees in I ∪A
are also called elementary trees.
We refer to the root of an elementary tree t as
Rt. Each auxiliary tree has exactly one distin-
guished leaf, which is called the foot. We refer
to the foot of an auxiliary tree t as Ft. We let
V denote the set of all nodes in the elementary
trees.
For each leaf N in an elementary tree, except
when it is a foot, we deﬁne label(N) to be the
label of the node, which is either a terminal from
Σ or the empty string ǫ. For each other node
N, label(N) is an element from NT.
At a node N in a tree such that label(N) ∈
NT an operation called adjunction can be ap-
plied, which excises the tree at N and inserts
an auxiliary tree.
Function φ assigns a probability to each ad-
junction. The probability of adjunction of t ∈A
at node N is denoted by φ(t, N). The probabil-
ity that at N no adjunction is applied is denoted
by φ(nil, N).
We assume that each STAG G
that we consider is proper. That is, for each
N such that label(N) ∈NT,
X
t∈A∪{nil}
φ(t, N) = 1.
For each non-leaf node N we construct the
string cdn(N) = c
N1 · · · d
Nm from the (ordered)
list of children nodes N1, . . . , Nm by deﬁning,
for each d such that 1 ≤d ≤m, c
Nd = label(Nd)
in case label(Nd) ∈Σ ∪{ǫ}, and c
Nd = Nd oth-
erwise. In other words, children nodes are re-
placed by their labels unless the labels are non-
terminal symbols.
To simplify the exposition, we assume an ad-
ditional node for each auxiliary tree t, which
we denote by ⊥. This is the unique child of the
actual foot node Ft. That is, we change the def-
inition of cdn such that cdn(Ft) = ⊥for each
auxiliary tree t. We set
V ⊥= {N ∈V | label(N) ∈NT} ∪Σ ∪{⊥}.
We use symbols a, b, c, . . . to range over Σ,
symbols v, w, x, . . . to range over Σ∗, sym-
bols N, M, . . . to range over V ⊥, and symbols
α, β, γ, . . . to range over (V ⊥)∗. We use t, t′, . . .
to denote trees in I ∪A or subtrees thereof.
We deﬁne the predicate dft on elements from
V ⊥as dft(N) if and only if (i) N ∈V and N
dominates ⊥, or (ii) N = ⊥.
We extend dft
to strings of the form N1 . . . Nm ∈(V ⊥)∗by
deﬁning dft(N1 . . . Nm) if and only if there is a
d (1 ≤d ≤m) such that dft(Nd).
For some logical expression p, we deﬁne
δ(p) = 1 iﬀp is true, δ(p) = 0 otherwise.
3
Overview
The approach we adopt in the next section to
derive a method for the computation of preﬁx
probabilities for TAGs is based on transforma-
tions of equations. Here we informally discuss
the general ideas underlying equation transfor-
mations.
Let w = a1a2 · · · an ∈Σ∗be a string and let
N ∈V ⊥. We use the following representation
which is standard in tabular methods for TAG
parsing. An item is a tuple [N, i, j, f1, f2] rep-
resenting the set of all trees t such that (i) t is a
subtree rooted at N of some derived elementary
tree; and (ii) t’s root spans from position i to
position j in w, t’s foot node spans from posi-
tion f1 to position f2 in w. In case N does not
dominate the foot, we set f1 = f2 = −. We gen-
eralize in the obvious way to items [t, i, j, f1, f2],
where t is an elementary tree, and [α, i, j, f1, f2],
where cdn(N) = αβ for some N and β.
To introduce our approach, let us start with
some considerations concerning the TAG pars-
ing problem. When parsing w with a TAG G,
one usually composes items in order to con-
struct new items spanning a larger portion of
the input string. Assume there are instances of
auxiliary trees t and t′ in G, where the yield of
t′, apart from its foot, is the empty string. If
φ(t, N) > 0 for some node N on the spine of t′,
and we have recognized an item [Rt, i, j, f1, f2],
then we may adjoin t at N and hence deduce
the existence of an item [Rt′, i, j, f1, f2] (see
Fig. 1(a)).
Similarly, if t can be adjoined at
a node N to the left of the spine of t′ and
f1 = f2, we may deduce the existence of an item
[Rt′, i, j, j, j] (see Fig. 1(b)). Importantly, one
or more other auxiliary trees with empty yield
could wrap the tree t′ before t adjoins. Adjunc-
tions in this situation are potentially nontermi-
nating.
One may argue that situations where auxil-
iary trees have empty yield do not occur in prac-
tice, and are even by deﬁnition excluded in the

i
i
j
j
f1
f1
f2
f2
Rt
Rt
Ft
Ft
N
N
Rt′
Rt′
Ft′
Ft′
ǫ
ǫ
ǫ
ǫ
t
t
t′
t′
spine
(a)
(b)
Figure 1:
Wrapping in auxiliary trees with
empty yield
case of lexicalized TAGs. However, in the com-
putation of the preﬁx probability we must take
into account trees with non-empty yield which
behave like trees with empty yield because their
lexical nodes fall to the right of the right bound-
ary of the preﬁx string. For example, the two
cases previously considered in Fig. 1 now gen-
eralize to those in Fig. 2.
i
i
n
n
f1
f1
f2
f2
Rt
Rt
Ft
Ft
Rt′
Rt′
Ft′
Ft′
ǫ
ǫ
ǫ
ǫ
spine
(a)
(b)
Figure 2:
Wrapping of auxiliary trees when
computing the preﬁx probability
To derive a method for the computation of
preﬁx probabilities, we give some simple recur-
sive equations.
Each equation decomposes an
item into other items in all possible ways, in
the sense that it expresses the probability of
that item as a function of the probabilities of
items associated with equal or smaller portions
of the input.
In specifying the equations, we exploit tech-
niques used in the parsing of incomplete in-
put (Lang, 1988).
This allows us to compute
the preﬁx probability as a by-product of com-
puting the inside probability.
In order to avoid the problem of nontermi-
nation outlined above, we transform our equa-
tions to remove inﬁnite recursion, while preserv-
ing the correctness of the probability computa-
tion.
The transformation of the equations is
explained as follows. For an item I, the span
of I, written σ(I), is the 4-tuple representing
the 4 input positions in I. We will deﬁne an
equivalence relation on spans that relates to the
portion of the input that is covered. The trans-
formations that we apply to our equations pro-
duce two new sets of equations. The ﬁrst set
of equations are concerned with all possible de-
compositions of a given item I into set of items
of which one has a span equivalent to that of I
and the others have an empty span. Equations
in this set represent endless recursion. The sys-
tem of all such equations can be solved indepen-
dently of the actual input w. This is done once
for a given grammar.
The second set of equations have the property
that, when evaluated, recursion always termi-
nates. The evaluation of these equations com-
putes the probability of the input string modulo
the computation of some parts of the derivation
that do not contribute to the input itself. Com-
bination of the second set of equations with the
solutions obtained from the ﬁrst set allows the
eﬀective computation of the preﬁx probability.
4
Computing Preﬁx Probabilities
This section develops an algorithm for the com-
putation of preﬁx probabilities for stochastic
TAGs.
4.1
General equations
The preﬁx probability is given by:
X
w∈Σ∗
Pr(a1 · · · anw)
=
X
t∈I
P([t, 0, n, −, −]),
where P is a function over items recursively de-
ﬁned as follows:
P([t, i, j, f1, f2]) = P([Rt, i, j, f1, f2]);
(1)
P([αN, i, j, −, −]) =
(2)
X
k(i ≤k ≤j)
P([α, i, k, −, −]) · P([N, k, j, −, −]),
if α ̸= ǫ ∧¬dft(αN);
P([αN, i, j, f1, f2]) =
(3)
X
k(i ≤k ≤f1)
P([α, i, k, −, −]) · P([N, k, j, f1, f2]),
if α ̸= ǫ ∧dft(N);

P([αN, i, j, f1, f2]) =
(4)
X
k(f2 ≤k ≤j)
P([α, i, k, f1, f2]) · P([N, k, j, −, −]),
if α ̸= ǫ ∧dft(α);
P([N, i, j, f1, f2]) =
(5)
φ(nil, N) · P([cdn(N), i, j, f1, f2]) +
X
f′
1, f′
2(i ≤f′
1 ≤f1 ∧f2 ≤f′
2 ≤j)
P([cdn(N), f ′
1, f ′
2, f1, f2]) ·
X
t∈A
φ(t, N) · P([t, i, j, f ′
1, f ′
2]),
if N ∈V ∧dft(N);
P([N, i, j, −, −]) =
(6)
φ(nil, N) · P([cdn(N), i, j, −, −]) +
X
f′
1, f′
2(i ≤f′
1 ≤f′
2 ≤j)
P([cdn(N), f ′
1, f ′
2, −, −]) ·
X
t∈A
φ(t, N) · P([t, i, j, f ′
1, f ′
2]),
if N ∈V ∧¬dft(N);
P([a, i, j, −, −]) =
(7)
δ(i + 1 = j ∧aj = a) + δ(i = j = n);
P([⊥, i, j, f1, f2]) = δ(i = f1 ∧j = f2);
(8)
P([ǫ, i, j, −, −]) = δ(i = j).
(9)
Term P([t, i, j, f1, f2]) gives the inside probabil-
ity of all possible trees derived from elementary
tree t, having the indicated span over the input.
This is decomposed into the contribution of each
single node of t in equations (1) through (6).
In equations (5) and (6) the contribution of a
node N is determined by the combination of
the inside probabilities of N’s children and by
all possible adjunctions at N.
In (7) we rec-
ognize some terminal symbol if it occurs in the
preﬁx, or ignore its contribution to the span if it
occurs after the last symbol of the preﬁx. Cru-
cially, this step allows us to reduce the compu-
tation of preﬁx probabilities to the computation
of inside probabilities.
4.2
Terminating equations
In general, the recursive equations (1) to (9)
are not directly computable.
This is because
the value of P([A, i, j, f, f ′]) might indirectly de-
pend on itself, giving rise to nontermination.
We therefore rewrite the equations.
We deﬁne an equivalence relation over spans,
that expresses when two items are associated
with equivalent portions of the input:
(i′, j′, f ′
1, f ′
2) ≈(i, j, f1, f2) if and only if
((i′, j′) = (i, j))∧
((f ′
1, f ′
2) = (f1, f2)∨
((f ′
1 = f ′
2 = i∨f ′
1 = f ′
2 = j ∨f ′
1 = f ′
2 = −)∧
(f1 = f2 = i∨f1 = f2 = j ∨f1 = f2 = −)))
We introduce two new functions Plow and
Psplit. When evaluated on some item I, Plow re-
cursively calls itself as long as some other item
I′ with a given elementary tree as its ﬁrst com-
ponent can be reached, such that σ(I) ≈σ(I′).
Plow returns 0 if the actual branch of recursion
cannot eventually reach such an item I′, thus
removing the contribution to the preﬁx proba-
bility of that branch. If item I′ is reached, then
Plow switches to Psplit. Complementary to Plow,
function Psplit tries to decompose an argument
item I into items I′ such that σ(I) ̸≈σ(I′). If
this is not possible through the actual branch
of recursion, Psplit returns 0. If decomposition
is indeed possible, then we start again with Plow
at items produced by the decomposition. The
eﬀect of this intermixing of function calls is the
simulation of the original function P, with Plow
being called only on potentially nonterminating
parts of the computation, and Psplit being called
on parts that are guaranteed to terminate.
Consider some derivation tree spanning some
portion of the input string, and the associated
derivation tree τ. There must be a unique ele-
mentary tree which is represented by a node in
τ that is the “lowest” one that entirely spans
the portion of the input of interest. (This node
might be the root of τ itself.) Then, for each
t ∈A and for each i, j, f1, f2 such that i < j
and i ≤f1 ≤f2 ≤j, we must have:
P([t, i, j, f1, f2]) =
(10)
X
t′ ∈A, f′
1, f′
2((i, j, f′
1, f′
2) ≈(i, j, f1, f2))
Plow([t, i, j, f1, f2], [t′, f ′
1, f ′
2]).
Similarly, for each t ∈I and for each i, j such
that i < j, we must have:
P([t, i, j, −, −]) =
(11)
X
t′ ∈{t} ∪A, f ∈{−, i, j}
Plow([t, i, j, −, −], [t′, f, f]).
The reason why Plow keeps a record of indices
f ′
1 and f ′
2, i.e., the spanning of the foot node
of the lowest tree (in the above sense) on which
Plow is called, will become clear later, when we
introduce equations (29) and (30).
We deﬁne Plow([t, i, j, f1, f2], [t′, f ′
1, f ′
2]) and
Plow([α, i, j, f1, f2], [t′, f ′
1, f ′
2]) for i
<
j and
(i, j, f1, f2)
≈
(i, j, f ′
1, f ′
2),
as
follows.

Plow([t, i, j, f1, f2], [t′, f ′
1, f ′
2]) =
(12)
Plow([Rt, i, j, f1, f2], [t′, f ′
1, f ′
2]) +
δ((t, f1, f2) = (t′, f ′
1, f ′
2)) ·
Psplit([Rt, i, j, f1, f2]);
Plow([αN, i, j, −, −], [t, f ′
1, f ′
2]) =
(13)
Plow([α, i, j, −, −], [t, f ′
1, f ′
2]) ·
P([N, j, j, −, −]) +
P([α, i, i, −, −]) ·
Plow([N, i, j, −, −], [t, f ′
1, f ′
2]),
if α ̸= ǫ ∧¬dft(αN);
Plow([αN, i, j, f1, f2], [t, f ′
1, f ′
2]) =
(14)
δ(f1 = j) · Plow([α, i, j, −, −], [t, f ′
1, f ′
2]) ·
P([N, j, j, f1, f2]) +
P([α, i, i, −, −]) ·
Plow([N, i, j, f1, f2], [t, f ′
1, f ′
2]),
if α ̸= ǫ ∧dft(N);
Plow([αN, i, j, f1, f2], [t, f ′
1, f ′
2]) =
(15)
Plow([α, i, j, f1, f2], [t, f ′
1, f ′
2]) ·
P([N, j, j, −, −]) +
δ(i = f2) · P([α, i, i, f1, f2]) ·
Plow([N, i, j, −, −], [t, f ′
1, f ′
2]),
if α ̸= ǫ ∧dft(α);
Plow([N, i, j, f1, f2], [t, f ′
1, f ′
2]) =
(16)
φ(nil, N) ·
Plow([cdn(N), i, j, f1, f2], [t, f ′
1, f ′
2]) +
Plow([cdn(N), i, j, f1, f2], [t, f ′
1, f ′
2]) ·
P
t′∈A φ(t′, N) · P([t′, i, j, i, j]) +
P([cdn(N), f1, f2, f1, f2]) ·
X
t′∈A
φ(t′, N)·Plow([t′, i, j, f1, f2], [t, f ′
1, f ′
2]),
if N ∈V ∧dft(N);
Plow([N, i, j, −, −], [t, f ′
1, f ′
2]) =
(17)
φ(nil, N) ·
Plow([cdn(N), i, j, −, −], [t, f ′
1, f ′
2]) +
Plow([cdn(N), i, j, −, −], [t, f ′
1, f ′
2]) ·
P
t′∈A φ(t′, N) · P([t′, i, j, i, j]) +
X
f′′
1 , f′′
2 (f′′
1 = f′′
2 = i ∨f′′
1 = f′′
2 = j)
P([cdn(N), f ′′
1 , f ′′
2 , −, −]) ·
X
t′∈A
φ(t′, N)·Plow([t′, i, j, f ′′
1 , f ′′
2 ], [t, f ′
1, f ′
2]),
if N ∈V ∧¬dft(N);
Plow([a, i, j, −, −], [t, f ′
1, f ′
2]) = 0;
(18)
Plow([⊥, i, j, f1, f2], [t, f ′
1, f ′
2]) = 0;
(19)
Plow([ǫ, i, j, −, −], [t, f ′
1, f ′
2]) = 0.
(20)
The deﬁnition of Plow parallels the one of P
given in §4.1. In (12), the second term in the
right-hand side accounts for the case in which
the tree we are visiting is the “lowest” one on
which Plow should be called. Note how in the
above equations Plow must be called also on
nodes that do not dominate the footnode of the
elementary tree they belong to (cf. the deﬁnition
of ≈). Since no call to Psplit is possible through
the terms in (18), (19) and (20), we must set
the right-hand side of these equations to 0.
The speciﬁcation of Psplit([α, i, j, f1, f2]) is
given below. Again, the deﬁnition parallels the
one of P given in §4.1.
Psplit([αN, i, j, −, −]) =
(21)
X
k(i < k < j)
P([α, i, k, −, −]) · P([N, k, j, −, −]) +
Psplit([α, i, j, −, −]) · P([N, j, j, −, −]) +
P([α, i, i, −, −]) · Psplit([N, i, j, −, −]),
if α ̸= ǫ ∧¬dft(αN);
Psplit([αN, i, j, f1, f2]) =
(22)
X
k(i < k ≤f1 ∧k < j)
P([α, i, k, −, −]) · P([N, k, j, f1, f2]) +
δ(f1 = j) · Psplit([α, i, j, −, −]) ·
P([N, j, j, f1, f2]) +
P([α, i, i, −, −]) · Psplit([N, i, j, f1, f2]),
if α ̸= ǫ ∧dft(N);
Psplit([αN, i, j, f1, f2]) =
(23)
X
k(i < k ∧f2 ≤k < j)
P([α, i, k, f1, f2]) · P([N, k, j, −, −]) +
Psplit([α, i, j, f1, f2]) · P([N, j, j, −, −]) +
δ(i = f2) · P([α, i, i, f1, f2]) ·
Psplit([N, i, j, −, −]),
if α ̸= ǫ ∧dft(α);
Psplit([N, i, j, f1, f2]) =
(24)
φ(nil, N) · Psplit([cdn(N), i, j, f1, f2]) +
X
f′
1, f′
2 (i ≤f′
1 ≤f1 ∧f2 ≤f′
2 ≤j ∧
(f′
1, f′
2) ̸= (i, j) ∧(f′
1, f′
2) ̸= (f1, f2))
P([cdn(N), f ′
1, f ′
2, f1, f2]) ·
X
t∈A
φ(t, N) · P([t, i, j, f ′
1, f ′
2]) +
Psplit([cdn(N), i, j, f1, f2]) ·
X
t∈A
φ(t, N) · P([t, i, j, i, j]),

if N ∈V ∧dft(N);
Psplit([N, i, j, −, −]) =
(25)
φ(nil, N) · Psplit([cdn(N), i, j, −, −]) +
X
f′
1, f′
2 (i ≤f′
1 ≤f′
2 ≤j ∧(f′
1, f′
2) ̸= (i, j) ∧
¬(f′
1 = f′
2 = i ∨f′
1 = f′
2 = j))
P([cdn(N), f ′
1, f ′
2, −, −]) ·
X
t∈A
φ(t, N) · P([t, i, j, f ′
1, f ′
2]) +
Psplit([cdn(N), i, j, −, −]) ·
X
t∈A
φ(t, N) · P([t, i, j, i, j]),
if N ∈V ∧¬dft(N);
Psplit([a, i, j, −, −]) = δ(i + 1 = j ∧aj = a); (26)
Psplit([⊥, i, j, f1, f2]) = 0;
(27)
Psplit([ǫ, i, j, −, −]) = 0.
(28)
We can now separate those branches of re-
cursion that terminate on the given input from
the cases of endless recursion. We assume be-
low that Psplit([Rt, i, j, f ′
1, f ′
2]) > 0. Even if this
is not always valid, for the purpose of deriving
the equations below, this assumption does not
lead to invalid results. We deﬁne a new function
Pouter, which accounts for probabilities of sub-
derivations that do not derive any words in the
preﬁx, but contribute structurally to its deriva-
tion:
Pouter([t, i, j, f1, f2], [t′, f ′
1, f ′
2]) =
(29)
Plow([t, i, j, f1, f2], [t′, f ′
1, f ′
2])
Psplit([Rt′, i, j, f ′
1, f ′
2])
;
Pouter([α, i, j, f1, f2], [t′, f ′
1, f ′
2]) =
(30)
Plow([α, i, j, f1, f2], [t′, f ′
1, f ′
2])
Psplit([Rt′, i, j, f ′
1, f ′
2])
.
We can now eliminate the inﬁnite recur-
sion that arises in (10) and (11) by rewriting
P([t, i, j, f1, f2]) in terms of Pouter:
P([t, i, j, f1, f2]) =
(31)
X
t′ ∈A, f′
1, f′
2((i, j, f′
1, f′
2) ≈(i, j, f1, f2))
Pouter([t, i, j, f1, f2], [t′, f ′
1, f ′
2]) ·
Psplit([Rt′, i, j, f ′
1, f ′
2]);
P([t, i, j, −, −]) =
(32)
X
t′ ∈{t} ∪A, f ∈{−, i, j}
Pouter([t, i, j, −, −], [t′, f, f]) ·
Psplit([Rt′, i, j, f, f]).
Equations for Pouter will be derived in the next
subsection.
In summary, terminating computation of pre-
ﬁx probabilities should be based on equa-
tions (31) and (32), which replace (1), along
with equations (2) to (9) and all the equations
for Psplit.
4.3
Oﬀ-line Equations
In this section we derive equations for function
Pouter introduced in §4.2 and deal with all re-
maining cases of equations that cause inﬁnite
recursion.
In some cases, function P can be computed
independently of the actual input.
For any
i < n we can consistently deﬁne the following
quantities, where t ∈I ∪A and α ∈V ⊥or
cdn(N) = αβ for some N and β:
Ht
=
P([t, i, i, f, f]);
Hα
=
P([α, i, i, f ′, f ′]),
where f = i if t ∈A, f = −otherwise, and f ′ =
i if dft(α), f = −otherwise. Thus, Ht is the
probability of all derived trees obtained from t,
with no lexical node at their yields. Quantities
Ht and Hα can be computed by means of a sys-
tem of equations which can be directly obtained
from equations (1) to (9). Similar quantities as
above must be introduced for the case i = n.
For instance, we can set H′
t = P([t, n, n, f, f]),
f speciﬁed as above, which gives the probabil-
ity of all derived trees obtained from t (with no
restriction at their yields).
Function Pouter is also independent of the
actual input.
Let us focus here on the case
f1, f2 ̸∈{i, j, −} (this enforces (f1, f2) = (f ′
1, f ′
2)
below). For any i, j, f1, f2 < n, we can consis-
tently deﬁne the following quantities.
Lt,t′
=
Pouter([t, i, j, f1, f2], [t′, f ′
1, f ′
2]);
Lα,t′
=
Pouter([α, i, j, f1, f2], [t′, f ′
1, f ′
2]).
In the case at hand, Lt,t′ is the probability of all
derived trees obtained from t such that (i) no
lexical node is found at their yields; and (ii) at
some ‘unﬁnished’ node dominating the foot of
t, the probability of the adjunction of t′ has al-
ready been accounted for, but t′ itself has not
been adjoined.
It is straightforward to establish a system of
equations for the computation of Lt,t′ and Lα,t′,
by rewriting equations (12) to (20) according
to (29) and (30). For instance, combining (12)
and (29) gives (using the above assumptions on
f1 and f2):
Lt,t′
=
LRt,t′ + δ(t = t′).
Also, if α ̸= ǫ and dft(N), combining (14)
and (30) gives (again, using previous assump-

tions on f1 and f2; note that the Hα’s are known
terms here):
LαN,t′
=
Hα · LN,t′.
For any i, f1, f2 < n and j = n, we also need to
deﬁne:
L′
t,t′
=
Pouter([t, i, n, f1, f2], [t′, f ′
1, f ′
2]);
L′
α,t′
=
Pouter([α, i, n, f1, f2], [t′, f ′
1, f ′
2]).
Here L′
t,t′ is the probability of all derived trees
obtained from t with a node dominating the
foot node of t, that is an adjunction site for t′
and is ‘unﬁnished’ in the same sense as above,
and with lexical nodes only in the portion of
the tree to the right of that node.
When we
drop our assumption on f1 and f2, we must
(pre)compute in addition terms of the form
Pouter([t, i, j, i, i], [t′, i, i]) and Pouter([t, i, j, i, i],
[t′, j, j]) for i < j < n, Pouter([t, i, n, f1, n],
[t′, f ′
1, f ′
2]) for i < f1 < n, Pouter([t, i, n, n, n],
[t′, f ′
1, f ′
2]) for i < n, and similar. Again, these
are independent of the choice of i, j and f1. Full
treatment is omitted due to length restrictions.
5
Complexity and concluding
remarks
We have presented a method for the computa-
tion of the preﬁx probability when the underly-
ing model is a Tree Adjoining Grammar. Func-
tion Psplit is the core of the method. Its equa-
tions can be directly translated into an eﬀective
algorithm, using standard functional memoiza-
tion or other tabular techniques. It is easy to
see that such an algorithm can be made to run
in time O(n6), where n is the length of the input
preﬁx.
All the quantities introduced in §4.3 (Ht,
Lt,t′, etc.)
are independent of the input and
should be computed oﬀ-line, using the system of
equations that can be derived as indicated. For
quantities Ht we have a non-linear system, since
equations (2) to (6) contain quadratic terms.
Solutions can then be approximated to any de-
gree of precision using standard iterative meth-
ods, as for instance those exploited in (Stolcke,
1995). Under the hypothesis that the grammar
is consistent, that is Pr(L(G)) = 1, all quanti-
ties H′
t and H′
α evaluate to one. For quantities
Lt,t′ and the like, §4.3 provides linear systems
whose solutions can easily be obtained using
standard methods.
Note also that quantities
Lα,t′ are only used in the oﬀ-line computation
of quantities Lt,t′, they do not need to be stored
for the computation of preﬁx probabilities (com-
pare equations for Lt,t′ with (31) and (32)).
We can easily develop implementations of our
method that can compute preﬁx probabilities
incrementally. That is, after we have computed
the preﬁx probability for a preﬁx a1 · · · an, on in-
put an+1 we can extend the calculation to preﬁx
a1 · · · anan+1 without having to recompute all
intermediate steps that do not depend on an+1.
This step takes time O(n5).
In this paper we have assumed that the pa-
rameters of the stochastic TAG have been pre-
viously estimated.
In practice, smoothing to
avoid sparse data problems plays an important
role. Smoothing can be handled for preﬁx prob-
ability computation in the following ways. Dis-
counting methods for smoothing simply pro-
duce a modiﬁed STAG model which is then
treated as input to the preﬁx probability com-
putation.
Smoothing using methods such as
deleted interpolation which combine class-based
models with word-based models to avoid sparse
data problems have to be handled by a cognate
interpolation of preﬁx probability models.
References
C. Chelba, D. Engle, F. Jelinek, V. Jimenez, S. Khu-
danpur, L. Mangu, H. Printz, E. Ristad, A. Stolcke,
R. Rosenfeld, and D. Wu. 1997. Structure and per-
formance of a dependency language model. In Proc.
of Eurospeech 97, volume 5, pages 2775–2778.
F. Jelinek and J. Laﬀerty. 1991. Computation of the
probability of initial substring generation by stochas-
tic context-free grammars.
Computational Linguis-
tics, 17(3):315–323.
A. K. Joshi and Y. Schabes. 1992. Tree-adjoining gram-
mars and lexicalized grammars.
In M. Nivat and
A. Podelski, editors, Tree automata and languages,
pages 409–431. Elsevier Science.
A. K. Joshi. 1988. An introduction to tree adjoining
grammars. In A. Manaster-Ramer, editor, Mathemat-
ics of Language. John Benjamins, Amsterdam.
B. Lang. 1988. Parsing incomplete sentences. In Proc. of
the 12th International Conference on Computational
Linguistics, volume 1, pages 365–371, Budapest.
O. Rambow and A. Joshi. 1995. A formal look at de-
pendency grammars and phrase-structure grammars,
with special consideration of word-order phenomena.
In Leo Wanner, editor, Current Issues in Meaning-
Text Theory. Pinter, London.
Y. Schabes. 1992. Stochastic lexicalized tree-adjoining
grammars. In Proc. of COLING ’92, volume 2, pages
426–432, Nantes, France.
B. Srinivas. 1996. “Almost Parsing” technique for lan-
guage modeling. In Proc. ICSLP ’96, volume 3, pages
1173–1176, Philadelphia, PA, Oct 3-6.
A. Stolcke. 1995. An eﬃcient probabilistic context-free
parsing algorithm that computes preﬁx probabilities.
Computational Linguistics, 21(2):165–201.
J. H. Wright and E. N. Wrigley. 1989. Probabilistic LR
parsing for speech recognition. In IWPT ’89, pages
105–114.
